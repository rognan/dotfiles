#!/bin/sh
#
# Backs up existing files and folders and then symlinks files into $HOME

set -e
set -u

abspath () {
    case "$1" in
        /*)
        printf "%s\n" "$1"
        ;;

        *)
        printf "%s\n" "$PWD/$1"
        ;;
    esac
}

sources() {
    for i in *;do echo "${i}"; done | egrep $1
}

now=$(date +%Y-%m-%dT%H.%M)

# Script directory
src_dir=$(dirname $(abspath $0))

# Files to dot and link up in $HOME
ldfiles="(bash|functions|gitc|gitm|vim)"

# Folders to link content into in the correct places
linside="(^bin$)"

# Existing files will be backed up here
backup="$HOME/backup/dotfiles/${now}_dotfiles.tar.gz"

cmd_file="${src_dir}/commands.sh"

# These are the files already mapped up in your $HOME directory
inventory() {
	# Give me all real dotfiles in $HOME/ that has a matching file (with or without a dot) in ./
	# Two find commands because '-type f -o -type d' does not work when you also want to do '-exec'
	find $HOME -maxdepth 1 -type f -exec echo "{}" \; | egrep "$(sources ${ldfiles})";
	find $HOME -maxdepth 1 -type d -exec echo "{}" \; | egrep "$(sources ${ldfiles})";

	# Give me all real files inside directories $HOME/{$linside} that has a matching path and filename inside ./{$linside}
	for dir in $(sources $linside); do find $HOME/$dir -type f 2>/dev/null -exec echo "{}" \; | egrep "$(find $dir -type f -exec echo "$HOME/{}" \;)"; done
}

run() {
	# Make sure we're in the source directory
	cd ${src_dir}

	# Clean up output of $(inventory) so that it is on one line since I don't know how to make that output pretty :'(
	tbu="" && for file in $(inventory); do tbu="${tbu} ${file}" ; done

	# Ensure backup directory is available and back up - 2>/dev/null to get rid of that pesky 'removing leading '/' message'
	echo "\$(mkdir -p $(dirname ${backup}))">>${cmd_file}
	echo "\$(tar -czf ${backup} -C $HOME ${tbu} ${cmd_file} 2>/dev/null || return 0)">>${cmd_file}
	
	# Symlink all dotfiles that should be directly in $HOME
	for df in $(sources $ldfiles); do
            if [[ -d $HOME/.$df ]]; then
                echo "\$(rm -rf $HOME/.$df/)">>${cmd_file}
            else
                echo "\$(rm -f $HOME/.$df)">>${cmd_file}
            fi
            echo "\$(ln -sf $src_dir/$df $HOME/.$df)">>${cmd_file}
	done

	# Symlink all dotfiles that should be inside a sub-directory of $HOME
	for sdir in $(sources $linside); do 
            sdf=$(find $sdir -type f 2>/dev/null -exec echo "{}" \;)
            for sf in $sdf; do
                target=$(dirname $HOME/$sf)
                echo "\$(rm -f $HOME/$sf)">>${cmd_file}
                echo "\$(mkdir -p ${target})">>${cmd_file}
                echo "\$(ln -sf $src_dir/$sf $HOME/$sf)">>${cmd_file}
            done
	done
}

# Start out in script directory
cd ${src_dir}

# Let's not overwrite an existing file with content.
if [ -s ${cmd_file} ]
then 
	echo "Halting run of $0 because ${cmd_file} exists and is not empty"
	exit 0
fi

# Create command file
echo "#!/bin/sh">${cmd_file}
echo "#">>${cmd_file}
echo "# This file was automatically generated by ${src_dir}/${0}">>${cmd_file}
echo "# Date: ${now}">>${cmd_file}
echo "">>${cmd_file}
echo "set -e">>${cmd_file}
echo "set -u">>${cmd_file}
echo "">>${cmd_file}

$(run)

# Run it and exit if --force is given
[[ ($# = 1) && ($1 == '--force') ]] && $(sh ${cmd_file}) && exit 0

# Just make the shell script - I really should make a usage() + case/esac
[[ ($# = 1) && ($1 == '--script') ]] && exit 0

printf "\n%s\n\n" "This is the script I plan to run:"
cat ${cmd_file}

read -p "Shall I proceed? [y/n]: " yepNope
[[ $yepNope = 'y' || $yepNope = 'Y' ]] || rm ${cmd_file} && exit 0

sh ${cmd_file} && rm ${cmd_file}

echo "Done"
